<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quest Board</title>
  <!-- Bootstrap for styling -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Custom styles -->
  <link href="styles.css" rel="stylesheet">
</head>
<body>
  <div class="container">
    <div id="app" class="mt-4">
      <h1 class="text-center mb-4">Quest Board</h1>
      
      <div class="student-info d-flex justify-content-between align-items-center">
        <div>
          <div class="student-name" id="studentName">Loading...</div>
          <div>Mighty Adventurer</div>
        </div>
        <div class="text-center">
          <div>Total Points</div>
          <div class="student-points" id="studentPoints">0</div>
        </div>
      </div>
      
      <div class="quest-filter btn-group w-100">
        <button onclick="filterTasks('all')" 
                id="filter-all"
                class="btn btn-custom">
          All Quests
        </button>
        <button onclick="filterTasks('homework')"
                id="filter-homework"
                class="btn btn-outline-secondary">
          Homework
        </button>
        <button onclick="filterTasks('chore')"
                id="filter-chore"
                class="btn btn-outline-secondary">
          Chores
        </button>
        <button onclick="filterTasks('completed')"
                id="filter-completed"
                class="btn btn-outline-secondary">
          Completed
        </button>
        <button onclick="toggleRecentFilter()"
                id="filter-recent"
                class="btn btn-outline-secondary">
          Recent: Off
        </button>
      </div>
      
      <div class="quest-board">
        <h2 class="board-title">Active Quests</h2>
        
        <div id="no-quests" class="text-center p-5" style="display: none;">
          <h3>No quests available</h3>
          <p>All quests have been completed. Great job!</p>
        </div>
        
        <div id="quest-container">
          <!-- Quests will be inserted here -->
        </div>
      </div>
      
      <div class="add-chore-form">
        <h3>Add New Chore</h3>
        <div class="mb-3">
          <label for="choreDescription" class="form-label">Chore Description</label>
          <input type="text" class="form-control" id="choreDescription" 
                 placeholder="Clean your room, Take out trash...">
        </div>
        <div class="mb-3">
          <label for="chorePoints" class="form-label">Reward Points</label>
          <input type="number" class="form-control" id="chorePoints" value="5" min="1" max="20">
        </div>
        <button onclick="addChore()" class="btn btn-custom">Add Chore</button>
      </div>
    </div>
  </div>
  
  <script>
    // Global data
    let appData = {
      students: [],
      tasks: [],
      activeFilter: 'all',  // Initialize filter to 'all'
      filteredLists: {}, // Store filtered lists for different tabs
      showRecentOnly: false // Flag to show only quests from the last 2 weeks
    };
    
    // DOM elements
    const questContainer = document.getElementById('quest-container');
    const noQuestsMessage = document.getElementById('no-quests');
    const studentNameEl = document.getElementById('studentName');
    const studentPointsEl = document.getElementById('studentPoints');
    
    // Load data on page load
    document.addEventListener('DOMContentLoaded', async () => {
      await loadData();
      renderTasks();
    });
    
    // Load data from Firestore
    async function loadData() {
      try {
        // Get Firebase modules from the global scope
        const { collection, getDocs } = window.firebaseModules;
        
        // Initialize with default data structure
        appData = {
          students: [],
          tasks: [],
          activeFilter: 'all',
          filteredLists: {},
          showRecentOnly: false
        };
        
        // Load students collection
        const studentsSnapshot = await getDocs(collection(window.db, "students"));
        if (!studentsSnapshot.empty) {
          studentsSnapshot.forEach((doc) => {
            const studentData = doc.data();
            appData.students.push({ 
              id: doc.id, 
              name: studentData.name,
              points: studentData.points
            });
          });
        } else {
          // If no students found, initialize with default student
          console.log('No students found in Firestore, initializing with default student');
          appData.students = [{ id: 1, name: 'Nuno', points: 0 }];
        }
        
        // Load quests collection (instead of tasks)
        const questsSnapshot = await getDocs(collection(window.db, "quests"));
        if (!questsSnapshot.empty) {
          questsSnapshot.forEach((doc) => {
            const questData = doc.data();
            // Ensure the status field is set to 'open' if it's undefined
            const status = questData.status || 'open';
            // Ensure type is set to a default value if it's undefined
            const type = questData.type || 'homework';
            
            appData.tasks.push({ 
              id: doc.id,
              date: questData.date,
              subject: questData.subject,
              description: questData.description,
              type: type,
              status: status,
              student_id: questData.student_id,
              points: questData.points || 5
            });
          });
        }
        
        console.log('Loaded data from Firestore:', appData); // Debug log
        
        // Set student info
        const student = appData.students[0];
        if (student) {
          studentNameEl.textContent = student.name;
          studentPointsEl.textContent = student.points;
        }
        
        // Render tasks after loading data
        renderTasks();
        
      } catch (error) {
        console.error('Error loading data from Firestore:', error);
        // Initialize with empty data in case of connection issues
        appData = {
          students: [{ id: 1, name: 'Nuno', points: 0 }],
          tasks: [],
          activeFilter: 'all',
          filteredLists: {},
          showRecentOnly: false
        };
        
        // Show a notification to the user about the connection issue
        alert('Could not connect to the database. Please check your internet connection and try again.');
        
        // Render empty task list
        renderTasks();
      }
    }
    
    // Save data to localStorage
    function saveData() {
      try {
        localStorage.setItem('questData', JSON.stringify(appData));
      } catch (error) {
        console.error('Error saving data to localStorage:', error);
      }
    }
    
    // Filter tasks
    function filterTasks(filter) {
      // Update active filter
      appData.activeFilter = filter;
      
      // Update filter button styles
      document.querySelectorAll('.quest-filter .btn').forEach(btn => {
        if (btn.id !== 'filter-recent') {
          btn.classList.remove('btn-custom');
          btn.classList.add('btn-outline-secondary');
        }
      });
      document.getElementById(`filter-${filter}`).classList.remove('btn-outline-secondary');
      document.getElementById(`filter-${filter}`).classList.add('btn-custom');
      
      // Clear cached filtered lists
      appData.filteredLists = {};
      
      // Render tasks with the new filter
      renderTasks();
    }
    
    // Add a new chore
    function addChore() {
      const description = document.getElementById('choreDescription').value.trim();
      const points = parseInt(document.getElementById('chorePoints').value) || 5;
      
      if (!description) {
        alert('Please enter a chore description');
        return;
      }
      
      // Create new chore
      const newChore = {
        id: Date.now(),
        date: new Date().toISOString().split('T')[0],
        subject: 'Chore',
        description: description,
        type: 'chore',
        status: 'open',
        student_id: 1,
        points: points
      };
      
      // Add to tasks array
      appData.tasks.push(newChore);
      
      // Save data
      saveData();
      
      // Reset form
      document.getElementById('choreDescription').value = '';
      document.getElementById('chorePoints').value = '5';
      
      // Re-render tasks
      renderTasks();
    }
    
    // Complete a task
    async function completeTask(taskId) {
      try {
        // Get Firebase modules from the global scope
        const { doc, updateDoc, getDoc } = window.firebaseModules;
        
        // Find task
        const taskIndex = appData.tasks.findIndex(task => task.id === taskId);
        if (taskIndex === -1) return;
        
        const task = appData.tasks[taskIndex];
        const isCompleted = task.status === 'completed';
        
        // Reference to the task document in Firestore
        const questRef = doc(window.db, "quests", taskId);
        
        // Reference to the student document in Firestore
        const studentRef = doc(window.db, "students", appData.students[0].id);
        const studentDoc = await getDoc(studentRef);
        
        if (!studentDoc.exists()) {
          throw new Error("Student document not found");
        }
        
        // Get current points
        const currentPoints = studentDoc.data().points || 0;
        const taskPoints = task.points;
        
        // Toggle completion status
        if (isCompleted) {
          // Undo completion
          await updateDoc(questRef, {
            status: 'open',
            completed_at: null
          });
          
          // Update student points (subtract points)
          await updateDoc(studentRef, {
            points: currentPoints - taskPoints
          });
          
          // Update local data
          appData.tasks[taskIndex].status = 'open';
          appData.tasks[taskIndex].completed_at = null;
          appData.students[0].points -= taskPoints;
        } else {
          // Complete the task
          await updateDoc(questRef, {
            status: 'completed',
            completed_at: new Date().toISOString()
          });
          
          // Update student points (add points)
          await updateDoc(studentRef, {
            points: currentPoints + taskPoints
          });
          
          // Update local data
          appData.tasks[taskIndex].status = 'completed';
          appData.tasks[taskIndex].completed_at = new Date().toISOString();
          appData.students[0].points += taskPoints;
          
          // Create confetti effect
          createConfetti();
        }
        
        // Update UI
        studentPointsEl.textContent = appData.students[0].points;
        
        // Clear cached filtered lists when a task status changes
        appData.filteredLists = {};
        
        // Animate the quest completion/undo
        const taskElement = document.getElementById(`task-${taskId}`);
        if (taskElement) {
          if (!isCompleted) {
            taskElement.classList.add('completion-animation');
          } else {
            taskElement.classList.add('undo-animation');
          }
          
          // After animation, re-render
          setTimeout(() => {
            renderTasks();
          }, 1000);
        }
      } catch (error) {
        console.error('Error updating quest completion status:', error);
        alert('Failed to update quest status. Please try again.');
        
        // Refresh data from Firebase to ensure UI is in sync
        await loadData();
        renderTasks();
      }
    }
    
    // Create confetti effect
    function createConfetti() {
      const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
      
      for (let i = 0; i < 50; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.left = `${Math.random() * 100}%`;
        confetti.style.setProperty('--rand', Math.random());
        
        document.body.appendChild(confetti);
        
        // Remove confetti after animation
        setTimeout(() => {
          confetti.remove();
        }, 3000);
      }
    }
    
    // Format date for display
    function formatDate(dateString) {
      // Handle Finnish date format (DD.MM.YYYY)
      if (dateString && dateString.includes('.')) {
        // No need to convert - the date is already in the desired format
        return dateString;
      }
      // For other formats, use the Date object (ISO strings, etc.)
      const date = new Date(dateString);
      return new Intl.DateTimeFormat('fi-FI').format(date);
    }
    
    // Parse Finnish format date (DD.MM.YYYY) to Date object
    function parseFinDate(dateString) {
      if (!dateString) return null;
      
      // If it's already a Date object or ISO string
      if (dateString instanceof Date || (dateString && !dateString.includes('.'))) {
        return new Date(dateString);
      }
      
      // Handle Finnish date format (DD.MM.YYYY)
      if (dateString && dateString.includes('.')) {
        const parts = dateString.split('.');
        if (parts.length >= 3) {
          // Finnish format is day.month.year
          const day = parseInt(parts[0], 10);
          const month = parseInt(parts[1], 10) - 1; // JS months are 0-indexed
          const year = parseInt(parts[2], 10);
          return new Date(year, month, day);
        }
      }
      
      // If parsing fails, return null
      return null;
    }
    
    // Check if date is within the last 2 weeks
    function isWithinTwoWeeks(dateString) {
      const date = parseFinDate(dateString);
      if (!date) return false;
      
      const twoWeeksAgo = new Date();
      twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);
      
      return date >= twoWeeksAgo;
    }
    
    // Toggle 2-week filter
    function toggleRecentFilter() {
      appData.showRecentOnly = !appData.showRecentOnly;
      
      // Update button style
      const recentFilterBtn = document.getElementById('filter-recent');
      if (appData.showRecentOnly) {
        recentFilterBtn.classList.remove('btn-outline-secondary');
        recentFilterBtn.classList.add('btn-custom');
        recentFilterBtn.textContent = 'Recent: On';
      } else {
        recentFilterBtn.classList.remove('btn-custom');
        recentFilterBtn.classList.add('btn-outline-secondary');
        recentFilterBtn.textContent = 'Recent: Off';
      }
      
      // Re-render tasks with the new filter
      renderTasks();
    }
    
    // Format completed date for display
    function formatCompletedDate(dateString) {
      if (!dateString) return '';
      const date = new Date(dateString);
      return new Intl.DateTimeFormat('fi-FI', {
        day: 'numeric',
        month: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
      }).format(date);
    }
    
    // Get quest title based on task type and subject
    function getQuestTitle(task) {
      if (task.type === 'homework') {
        return `${task.subject} Quest`;
      } else {
        return 'House Quest';
      }
    }
    
    // Render tasks based on current filter
    function renderTasks() {
      // Clear container
      questContainer.innerHTML = '';
      
      console.log('Rendering tasks. Total tasks:', appData.tasks.length);
      console.log('Current filter:', appData.activeFilter);
      console.log('Show recent only:', appData.showRecentOnly);
      
      // Ensure activeFilter has a valid value
      if (!appData.activeFilter) {
        appData.activeFilter = 'all';
      }
      
      // Apply filters
      let filteredTasks = [];
      
      // Check if we already have this filtered list cached
      const cacheKey = `${appData.activeFilter}_${appData.showRecentOnly}`;
      if (appData.filteredLists[cacheKey]) {
        filteredTasks = appData.filteredLists[cacheKey];
      } else {
        // Basic type filtering
        if (appData.activeFilter === 'all') {
          filteredTasks = [...appData.tasks];
        } else if (appData.activeFilter === 'completed') {
          filteredTasks = appData.tasks.filter(task => task.status === 'completed');
        } else {
          filteredTasks = appData.tasks.filter(task => 
            task.type === appData.activeFilter && task.status !== 'completed'
          );
        }
        
        // Apply recent filter (2 weeks) if enabled
        if (appData.showRecentOnly) {
          filteredTasks = filteredTasks.filter(task => isWithinTwoWeeks(task.date));
        }
        
        // Sort by date (newest first)
        filteredTasks.sort((a, b) => {
          const dateA = parseFinDate(a.date);
          const dateB = parseFinDate(b.date);
          
          // If we can't parse either date, maintain original order
          if (!dateA || !dateB) return 0;
          
          // Sort descending (newest first)
          return dateB - dateA;
        });
        
        // Cache the filtered list
        appData.filteredLists[cacheKey] = filteredTasks;
      }
      
      console.log('Filtered tasks:', filteredTasks.length);
      
      // Show/hide no quests message
      if (filteredTasks.length === 0) {
        noQuestsMessage.style.display = 'block';
      } else {
        noQuestsMessage.style.display = 'none';
      }
      
      // Render each task
      filteredTasks.forEach(task => {
        console.log('Rendering task:', task);
        const taskElement = document.createElement('div');
        taskElement.id = `task-${task.id}`;
        
        // Generate subject class name by converting to lowercase and removing special characters
        let subjectClass = '';
        if (task.subject) {
          // Convert subject name to lowercase and normalize Finnish characters
          let normalizedSubject = task.subject.toLowerCase()
            .replace(/ä/g, 'a')  // Replace ä with a
            .replace(/ö/g, 'o')  // Replace ö with o
            .replace(/å/g, 'a')  // Replace å with a
            .replace(/\s+/g, ''); // Remove spaces
          
          subjectClass = `subject-${normalizedSubject}`;
        }
        
        taskElement.className = `quest ${task.type} ${task.status === 'completed' ? 'completed' : ''} ${subjectClass}`;
        
        taskElement.innerHTML = `
          <div class="d-flex justify-content-between align-items-start">
            <div>
              <div class="quest-title">${getQuestTitle(task)}</div>
              <div class="quest-description">${task.description}</div>
              <div class="text-muted mt-2">${formatDate(task.date)}</div>
            </div>
            <div class="d-flex flex-column align-items-end">
              <span class="quest-points mb-2">+${task.points} points</span>
              ${task.status !== 'completed' 
                ? `<button onclick="completeTask('${task.id}')" class="btn btn-sm btn-custom">Complete</button>`
                : `<div>
                     <small class="text-success">Completed ${formatCompletedDate(task.completed_at)}</small>
                     <button onclick="completeTask('${task.id}')" class="btn btn-sm btn-outline-secondary mt-1">Undo</button>
                   </div>`
              }
            </div>
          </div>
        `;
        
        questContainer.appendChild(taskElement);
      });
    }
  </script>
  <!-- Add before your closing </body> tag -->
<script type="module">
  // Import Firebase modules
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, getDoc, setDoc, updateDoc } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";

  // Your web app's Firebase configuration
  const firebaseConfig = {
    apiKey: "AIzaSyAkWib8nvqf4l__I9cu63_ykzbL2UEQLwo",
    authDomain: "questboard-17337.firebaseapp.com",
    projectId: "questboard-17337",
    storageBucket: "questboard-17337.firebasestorage.app",
    messagingSenderId: "427884628874",
    appId: "1:427884628874:web:d2e7a64b45c9edce9d5673"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  
  // Initialize Firestore
  window.db = getFirestore(app);
  window.firebaseModules = { collection, getDocs, doc, getDoc, setDoc, updateDoc };
</script>
</body>
</html>