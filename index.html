<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Quest Board</title>
  <!-- Bootstrap for styling -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <!-- Custom styles -->
  <link href="styles.css" rel="stylesheet">
  <!-- Due Date Calculation System -->
  <script src="duedate.js" defer></script>
</head>
<body>
  <div class="container">
    <div id="app" class="mt-4">
      <h1 class="text-center mb-4">Quest Board</h1>
      
      <div class="student-info d-flex justify-content-between align-items-center">
        <div>
          <div class="student-name" id="studentName">Loading...</div>
          <div>Mighty Adventurer</div>
        </div>
        <div class="text-center">
          <div>Total Points</div>
          <div class="student-points" id="studentPoints">0</div>
        </div>
      </div>
      
      <div class="quest-filter btn-group w-100">
        <button onclick="filterTasks('all')" 
                id="filter-all"
                class="btn btn-custom">
          All Quests
        </button>
        <button onclick="filterTasks('homework')"
                id="filter-homework"
                class="btn btn-outline-secondary">
          Homework
        </button>
        <button onclick="filterTasks('chore')"
                id="filter-chore"
                class="btn btn-outline-secondary">
          Chores
        </button>
        <button onclick="filterTasks('completed')"
                id="filter-completed"
                class="btn btn-outline-secondary">
          Completed
        </button>
        <button onclick="toggleRecentFilter()"
                id="filter-recent"
                class="btn btn-outline-secondary">
          Recent: Off
        </button>
      </div>
      
      <div class="quest-board">
        <h2 class="board-title">Active Quests</h2>
        
        <div id="no-quests" class="text-center p-5" style="display: none;">
          <h3>No quests available</h3>
          <p>All quests have been completed. Great job!</p>
        </div>
        
        <div id="quest-container">
          <!-- Quests will be inserted here -->
        </div>
      </div>
      
      <div class="add-chore-form">
        <h3>Add New Chore</h3>
        <div class="mb-3">
          <label for="choreDescription" class="form-label">Chore Description</label>
          <input type="text" class="form-control" id="choreDescription" 
                 placeholder="Clean your room, Take out trash...">
        </div>
        <div class="mb-3">
          <label for="chorePoints" class="form-label">Reward Points</label>
          <input type="number" class="form-control" id="chorePoints" value="5" min="1" max="20">
        </div>
        <button onclick="addChore()" class="btn btn-custom">Add Chore</button>
      </div>
    </div>
  </div>
  
  <script>
    // Global data
    let appData = {
      students: [],
      tasks: [],
      activeFilter: 'all',  // Initialize filter to 'all'
      filteredLists: {}, // Store filtered lists for different tabs
      showRecentOnly: false // Flag to show only quests from the last 2 weeks
    };
    
    // DOM elements
    const questContainer = document.getElementById('quest-container');
    const noQuestsMessage = document.getElementById('no-quests');
    const studentNameEl = document.getElementById('studentName');
    const studentPointsEl = document.getElementById('studentPoints');
    
    // Load data on page load
    document.addEventListener('DOMContentLoaded', async () => {
      await loadData();
      renderTasks();
    });
    
    // Load data from Firestore
    async function loadData() {
      try {
        // Get Firebase modules from the global scope
        const { collection, getDocs } = window.firebaseModules;
        
        // Initialize with default data structure
        appData = {
          students: [],
          tasks: [],
          activeFilter: 'all',
          filteredLists: {},
          showRecentOnly: false
        };
        
        // Load students collection
        const studentsSnapshot = await getDocs(collection(window.db, "students"));
        if (!studentsSnapshot.empty) {
          studentsSnapshot.forEach((doc) => {
            const studentData = doc.data();
            appData.students.push({ 
              id: doc.id, 
              name: studentData.name,
              points: studentData.points
            });
          });
        } else {
          // If no students found, initialize with default student
          console.log('No students found in Firestore, initializing with default student');
          appData.students = [{ id: 1, name: 'Nuno', points: 0 }];
        }
        
        // Load quests collection (instead of tasks)
        const questsSnapshot = await getDocs(collection(window.db, "quests"));
        if (!questsSnapshot.empty) {
          questsSnapshot.forEach((doc) => {
            const questData = doc.data();
            // Ensure the status field is set to 'open' if it's undefined
            const status = questData.status || 'open';
            // Ensure type is set to a default value if it's undefined
            const type = questData.type || 'homework';
            
            appData.tasks.push({ 
              id: doc.id,
              date: questData.date,
              subject: questData.subject,
              description: questData.description,
              type: type,
              status: status,
              student_id: questData.student_id,
              points: questData.points || 5
            });
          });
        }
        
        console.log('Loaded data from Firestore:', appData); // Debug log
        
        // Set student info
        const student = appData.students[0];
        if (student) {
          studentNameEl.textContent = student.name;
          studentPointsEl.textContent = student.points;
        }
        
        // Render tasks after loading data
        renderTasks();
        
      } catch (error) {
        console.error('Error loading data from Firestore:', error);
        // Initialize with empty data in case of connection issues
        appData = {
          students: [{ id: 1, name: 'Nuno', points: 0 }],
          tasks: [],
          activeFilter: 'all',
          filteredLists: {},
          showRecentOnly: false
        };
        
        // Show a notification to the user about the connection issue
        alert('Could not connect to the database. Please check your internet connection and try again.');
        
        // Render empty task list
        renderTasks();
      }
    }
    
    // Save data to localStorage
    function saveData() {
      try {
        localStorage.setItem('questData', JSON.stringify(appData));
      } catch (error) {
        console.error('Error saving data to localStorage:', error);
      }
    }
    
    // Filter tasks
    function filterTasks(filter) {
      // Update active filter
      appData.activeFilter = filter;
      
      // Update filter button styles
      document.querySelectorAll('.quest-filter .btn').forEach(btn => {
        if (btn.id !== 'filter-recent') {
          btn.classList.remove('btn-custom');
          btn.classList.add('btn-outline-secondary');
        }
      });
      document.getElementById(`filter-${filter}`).classList.remove('btn-outline-secondary');
      document.getElementById(`filter-${filter}`).classList.add('btn-custom');
      
      // Clear cached filtered lists
      appData.filteredLists = {};
      
      // Render tasks with the new filter
      renderTasks();
    }
    
    // Add a new chore
    async function addChore() {
      const description = document.getElementById('choreDescription').value.trim();
      const points = parseInt(document.getElementById('chorePoints').value) || 5;
      
      if (!description) {
        alert('Please enter a chore description');
        return;
      }
      
      try {
        // Get today's date in ISO format (YYYY-MM-DD)
        const today = new Date();
        const dateString = today.toISOString().split('T')[0];
        
        // Create new chore object
        let newChore = {
          date: dateString,
          subject: 'Chore',
          description: description,
          type: 'chore',
          status: 'open',
          student_id: appData.students[0].id,
          points: points
        };
        
        // Add due date to the chore using our dueDate utility
        newChore = await window.dueDate.addDueDateToQuest(newChore);
        
        // Add to Firestore
        const { addDoc, collection } = window.firebaseModules;
        const docRef = await addDoc(collection(window.db, "quests"), newChore);
        console.log('New chore added with ID:', docRef.id);
        
        // Reset form
        document.getElementById('choreDescription').value = '';
        document.getElementById('chorePoints').value = '5';
        
        // Reload data and render tasks
        await loadData();
        renderTasks();
      } catch (error) {
        console.error('Error adding chore:', error);
        alert('Error adding chore: ' + error.message);
      }
    }
    
    // Complete a task
    async function completeTask(taskId) {
      try {
        // Get Firebase modules from the global scope
        const { doc, updateDoc, getDoc } = window.firebaseModules;
        
        // Find task
        const taskIndex = appData.tasks.findIndex(task => task.id === taskId);
        if (taskIndex === -1) return;
        
        const task = appData.tasks[taskIndex];
        const isCompleted = task.status === 'completed';
        
        // Reference to the task document in Firestore
        const questRef = doc(window.db, "quests", taskId);
        
        // Reference to the student document in Firestore
        const studentRef = doc(window.db, "students", appData.students[0].id);
        const studentDoc = await getDoc(studentRef);
        
        if (!studentDoc.exists()) {
          throw new Error("Student document not found");
        }
        
        // Get current points
        const currentPoints = studentDoc.data().points || 0;
        const taskPoints = task.points;
        
        // Toggle completion status
        if (isCompleted) {
          // Undo completion
          await updateDoc(questRef, {
            status: 'open',
            completed_at: null
          });
          
          // Update student points (subtract points)
          await updateDoc(studentRef, {
            points: currentPoints - taskPoints
          });
          
          // Update local data
          appData.tasks[taskIndex].status = 'open';
          appData.tasks[taskIndex].completed_at = null;
          appData.students[0].points -= taskPoints;
        } else {
          // Complete the task
          await updateDoc(questRef, {
            status: 'completed',
            completed_at: new Date().toISOString()
          });
          
          // Update student points (add points)
          await updateDoc(studentRef, {
            points: currentPoints + taskPoints
          });
          
          // Update local data
          appData.tasks[taskIndex].status = 'completed';
          appData.tasks[taskIndex].completed_at = new Date().toISOString();
          appData.students[0].points += taskPoints;
          
          // Create confetti effect
          createConfetti();
        }
        
        // Update UI
        studentPointsEl.textContent = appData.students[0].points;
        
        // Clear cached filtered lists when a task status changes
        appData.filteredLists = {};
        
        // Animate the quest completion/undo
        const taskElement = document.getElementById(`task-${taskId}`);
        if (taskElement) {
          if (!isCompleted) {
            taskElement.classList.add('completion-animation');
          } else {
            taskElement.classList.add('undo-animation');
          }
          
          // After animation, re-render
          setTimeout(() => {
            renderTasks();
          }, 1000);
        }
      } catch (error) {
        console.error('Error updating quest completion status:', error);
        alert('Failed to update quest status. Please try again.');
        
        // Refresh data from Firebase to ensure UI is in sync
        await loadData();
        renderTasks();
      }
    }
    
    // Create confetti effect
    function createConfetti() {
      const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];
      
      for (let i = 0; i < 50; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.left = `${Math.random() * 100}%`;
        confetti.style.setProperty('--rand', Math.random());
        
        document.body.appendChild(confetti);
        
        // Remove confetti after animation
        setTimeout(() => {
          confetti.remove();
        }, 3000);
      }
    }
    
    // Format date for display
    function formatDate(dateString) {
      // Handle Finnish date format (DD.MM.YYYY)
      if (dateString && dateString.includes('.')) {
        // No need to convert - the date is already in the desired format
        return dateString;
      }
      // For other formats, use the Date object (ISO strings, etc.)
      const date = new Date(dateString);
      return new Intl.DateTimeFormat('fi-FI').format(date);
    }
    
    // Parse Finnish format date (DD.MM.YYYY) to Date object
    function parseFinDate(dateString) {
      if (!dateString) return null;
      
      // If it's already a Date object or ISO string
      if (dateString instanceof Date || (dateString && !dateString.includes('.'))) {
        return new Date(dateString);
      }
      
      // Handle Finnish date format (DD.MM.YYYY)
      if (dateString && dateString.includes('.')) {
        const parts = dateString.split('.');
        if (parts.length >= 3) {
          // Finnish format is day.month.year
          const day = parseInt(parts[0], 10);
          const month = parseInt(parts[1], 10) - 1; // JS months are 0-indexed
          const year = parseInt(parts[2], 10);
          return new Date(year, month, day);
        }
      }
      
      // If parsing fails, return null
      return null;
    }
    
    // Check if date is within the last 2 weeks
    function isWithinTwoWeeks(dateString) {
      const date = parseFinDate(dateString);
      if (!date) return false;
      
      const twoWeeksAgo = new Date();
      twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);
      
      return date >= twoWeeksAgo;
    }
    
    // Toggle 2-week filter
    function toggleRecentFilter() {
      appData.showRecentOnly = !appData.showRecentOnly;
      
      // Update button style
      const recentFilterBtn = document.getElementById('filter-recent');
      if (appData.showRecentOnly) {
        recentFilterBtn.classList.remove('btn-outline-secondary');
        recentFilterBtn.classList.add('btn-custom');
        recentFilterBtn.textContent = 'Recent: On';
      } else {
        recentFilterBtn.classList.remove('btn-custom');
        recentFilterBtn.classList.add('btn-outline-secondary');
        recentFilterBtn.textContent = 'Recent: Off';
      }
      
      // Re-render tasks with the new filter
      renderTasks();
    }
    
    // Format completed date for display
    function formatCompletedDate(dateString) {
      if (!dateString) return '';
      
      const date = new Date(dateString);
      const day = date.getDate().toString().padStart(2, '0');
      const month = (date.getMonth() + 1).toString().padStart(2, '0');
      const year = date.getFullYear();
      
      return `${day}.${month}.${year}`;
    }
    
    // Calculate due date based on subject and schedule
    async function calculateDueDate(subject, creationDate) {
      try {
        // Default to 7 days if calculation fails
        let defaultDueInterval = 7;
        
        // Convert creation date to a Date object if it's a string
        const createDate = typeof creationDate === 'string' 
          ? new Date(creationDate) 
          : creationDate;
        
        // Get the day of week (0 = Sunday, 1 = Monday, etc.)
        const creationDayNum = createDate.getDay();
        // Convert to day name
        const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
        const creationDay = dayNames[creationDayNum];
        
        console.log(`Calculating due date for ${subject} created on ${creationDay}`);
        
        // Fetch schedule configuration from Firestore
        const { doc, getDoc } = window.firebaseModules;
        const scheduleConfigRef = doc(window.db, "scheduleConfig", subject);
        const scheduleConfigSnap = await getDoc(scheduleConfigRef);
        
        if (scheduleConfigSnap.exists()) {
          const scheduleConfig = scheduleConfigSnap.data();
          const classDays = scheduleConfig.classDays || [];
          defaultDueInterval = scheduleConfig.defaultDueInterval || 7;
          
          console.log(`Class days for ${subject}: ${classDays.join(', ')}`);
          
          if (classDays.length > 0) {
            // Find the next class day after the creation date
            let nextClassDay = null;
            let daysToAdd = 1;
            
            // Check up to 14 days forward to find the next class
            while (!nextClassDay && daysToAdd <= 14) {
              // Calculate the next day
              const nextDate = new Date(createDate);
              nextDate.setDate(createDate.getDate() + daysToAdd);
              const nextDayNum = nextDate.getDay();
              const nextDayName = dayNames[nextDayNum];
              
              // Check if this is a class day for the subject
              if (classDays.includes(nextDayName)) {
                nextClassDay = nextDate;
                break;
              }
              
              daysToAdd++;
            }
            
            if (nextClassDay) {
              console.log(`Next ${subject} class is on ${nextClassDay.toDateString()}`);
              // Format the date in ISO format
              return nextClassDay.toISOString().split('T')[0];
            }
          }
        } else {
          console.log(`No schedule configuration found for ${subject}, using default interval of ${defaultDueInterval} days`);
        }
        
        // Fallback: use default due interval from config or 7 days
        const dueDate = new Date(createDate);
        dueDate.setDate(createDate.getDate() + defaultDueInterval);
        return dueDate.toISOString().split('T')[0];
        
      } catch (error) {
        console.error('Error calculating due date:', error);
        // Fallback to one week from creation
        const dueDate = new Date(creationDate);
        dueDate.setDate(dueDate.getDate() + 7);
        return dueDate.toISOString().split('T')[0];
      }
    }

    // Get quest title based on task type and subject
    function getQuestTitle(task) {
      if (task.type === 'homework') {
        return `${task.subject} Quest`;
      } else {
        return 'House Quest';
      }
    }
    
    // Render tasks based on current filter
    function renderTasks() {
      // Clear the container
      questContainer.innerHTML = '';
      
      // Check if there are any tasks
      if (!appData.tasks || appData.tasks.length === 0) {
        noQuestsMessage.style.display = 'block';
        return;
      }
      
      // Get the filtered list or filter now
      let tasksToRender = appData.filteredLists[appData.activeFilter];
      
      if (!tasksToRender) {
        // Apply filtering if it wasn't done before
        tasksToRender = appData.tasks.filter(task => {
          // Filter by type
          if (appData.activeFilter === 'homework' && task.type !== 'homework') {
            return false;
          }
          
          if (appData.activeFilter === 'chore' && task.type !== 'chore') {
            return false;
          }
          
          if (appData.activeFilter === 'completed' && task.status !== 'completed') {
            return false;
          }
          
          if (appData.activeFilter !== 'completed' && task.status === 'completed') {
            return false;
          }
          
          // Apply "recent" filter if enabled
          if (appData.showRecentOnly && !isWithinTwoWeeks(task.date)) {
            return false;
          }
          
          return true;
        });
        
        // Cache the filtered list
        appData.filteredLists[appData.activeFilter] = tasksToRender;
      }
      
      // Sort tasks by due date (if available), then by creation date
      tasksToRender.sort((a, b) => {
        // First sort by status (open before completed)
        if (a.status !== b.status) {
          return a.status === 'completed' ? 1 : -1;
        }
        
        // For open tasks, sort by due date if available
        if (a.status !== 'completed') {
          if (a.dueDate && b.dueDate) {
            return new Date(a.dueDate) - new Date(b.dueDate);
          } else if (a.dueDate) {
            return -1; // a has due date, b doesn't - a comes first
          } else if (b.dueDate) {
            return 1; // b has due date, a doesn't - b comes first
          }
        }
        
        // Otherwise, sort by creation date (newest first)
        return new Date(b.date) - new Date(a.date);
      });
      
      // Show/hide no quests message
      noQuestsMessage.style.display = tasksToRender.length === 0 ? 'block' : 'none';
      
      // Create task elements
      tasksToRender.forEach(task => {
        const taskElement = document.createElement('div');
        taskElement.className = `quest-item ${task.status === 'completed' ? 'completed' : ''}`;
        
        // Format the date for display
        const dateDisplay = formatDate(task.date);
        
        // Format due date for display if available
        const dueDateDisplay = task.dueDate ? window.dueDate.formatDueDate(task.dueDate) : '';
        
        // Create an HTML template for the task
        const questTitle = getQuestTitle(task);
        
        // Create an HTML structure with due date
        let taskHTML = `
          <div class="quest-header">
            <div class="quest-title">${questTitle}</div>
            <div class="quest-date">${dateDisplay}</div>
          </div>
          <div class="quest-description">${task.description}</div>
        `;
        
        // Add due date section if available
        if (dueDateDisplay) {
          // Determine if task is overdue (due date is in the past)
          const isOverdue = task.status !== 'completed' && 
                          task.dueDate && 
                          new Date(task.dueDate) < new Date() && 
                          new Date(task.dueDate).toDateString() !== new Date().toDateString();
          
          taskHTML += `
            <div class="quest-duedate ${isOverdue ? 'overdue' : ''}">
              <strong>Due:</strong> ${dueDateDisplay}
              ${isOverdue ? '<span class="overdue-label">OVERDUE</span>' : ''}
            </div>
          `;
        }
        
        // Add completion section for completed tasks
        if (task.status === 'completed' && task.completedDate) {
          taskHTML += `
            <div class="quest-completed-date">
              <strong>Completed:</strong> ${formatCompletedDate(task.completedDate)}
            </div>
          `;
        }
        
        // Add points and complete button for open tasks
        if (task.status !== 'completed') {
          taskHTML += `
            <div class="quest-footer">
              <div class="quest-points">+${task.points} points</div>
              <button class="btn btn-custom" onclick="completeTask('${task.id}')">
                Complete
              </button>
            </div>
          `;
        }
        
        // Set the HTML content
        taskElement.innerHTML = taskHTML;
        
        // Add to the quest container
        questContainer.appendChild(taskElement);
      });
    }
  </script>
  <!-- Add before your closing </body> tag -->
<script type="module">
  // Import Firebase modules
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js";
  import { getFirestore, collection, getDocs, doc, getDoc, setDoc, updateDoc } from "https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js";

  // Your web app's Firebase configuration
  const firebaseConfig = {
    apiKey: "AIzaSyAkWib8nvqf4l__I9cu63_ykzbL2UEQLwo",
    authDomain: "questboard-17337.firebaseapp.com",
    projectId: "questboard-17337",
    storageBucket: "questboard-17337.firebasestorage.app",
    messagingSenderId: "427884628874",
    appId: "1:427884628874:web:d2e7a64b45c9edce9d5673"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  
  // Initialize Firestore
  window.db = getFirestore(app);
  window.firebaseModules = { collection, getDocs, doc, getDoc, setDoc, updateDoc };
</script>
</body>
</html>